#!/usr/bin/env ruby

def usage(status)
  puts <<'End'
Usage: procmemsize command [args...]
End
  exit status
end

require 'tsort'

STDOUT.sync = true

class Hash
  include TSort
  alias tsort_each_node each_key
  def tsort_each_child(node, &block)
    fetch(node) { {} }.each_key(&block)
  end
end

class ProcessScanner
  def initialize(*roots)
    @not_interest = {}
    @roots = roots
  end

  def scan
    entries = get_entries
    status_hash = read_status(entries)
    trace(status_hash)
  end

  def get_entries
    entries = Dir.entries("/proc")

    # reject non-pid entries
    entries.reject! {|n| /\A\d+\z/ !~ n }

    # reject non-existing processes
    entries_hash = {}
    entries.each {|n| entries_hash[n.to_i] = true }
    @not_interest.reject! {|pid, _| !entries_hash[pid] }

    # reject not-interesting processes
    entries.reject! {|n| @not_interest[n.to_i] }

    entries
  end

  def read_status(entries)
    status_hash = {}
    entries.each {|n|
      pid = n.to_i
      status = {}
      begin
        f = File.open("/proc/#{n}/status")
      rescue Errno::ENOENT
        next
      end
      begin
        f.each_line {|line|
          if /^([A-Za-z]+):\s*(.*)/ =~ line.chomp
            key = $1
            val = $2
            status[key] = val
          end
        }
      ensure
        f.close
      end

      status_hash[pid] = status
    }
    status_hash
  end

  def trace(status_hash)
    parent_pid = {}
    children_pids = {}
    status_hash.each {|pid, status|
      if status['PPid']
        ppid = status['PPid'].to_i
        parent_pid[pid] = ppid
        children_pids[ppid] ||= {}
        children_pids[ppid][pid] = true
      end
    }

    pids = children_pids.tsort
    interest = []
    pids.reverse_each {|pid|
      if @roots.include? pid
        interest << status_hash[pid]
      elsif !parent_pid[pid]
        @not_interest[pid] = true
      elsif @not_interest[parent_pid[pid]]
        @not_interest[pid] = true
      else
        interest << status_hash[pid]
      end
    }
    interest
  end

  def self.parse_memsize(str)
    if /\A(\d+) kB\z/ =~ str
      return $1.to_i * 1024
    end
    raise "unexpected memsize format: #{str.inspect}"
  end
end

def update_top(scanner, top)
  begin
    interest = scanner.scan
  rescue TSort::Cyclic
    sleep 0.01
    retry
  end
  interest.each {|status|
    updated_keys = []
    status.each {|k,v|
      next if /\AVm/ !~ k
      if !top[k] || ProcessScanner.parse_memsize(top[k]) < ProcessScanner.parse_memsize(v)
        updated_keys << k
        top[k] = v
      end
    }
    if !updated_keys.empty?
      line = "#{status['Name']} (#{status['Pid']}):"
      updated_keys.sort.each {|k|
        line << " #{k}=#{status[k].gsub(/\s+/, '')}"
      }
      puts line
    end
  }
end

def main_invoke
  pipe_r, pipe_w = IO.pipe

  trap(:CHLD) { pipe_w.write_nonblock "a" }

  command_pid = fork {
    exec [ARGV[0], ARGV[0]], *ARGV[1..-1]
  }

  scanner = ProcessScanner.new(command_pid)
  top = {}

  while Process.waitpid(command_pid, Process::WNOHANG) == nil

    update_top(scanner, top)

    IO.select([pipe_r], nil, nil, 1)
    pipe_r.read_nonblock(4096) rescue nil
  end
  result = $?

  top.keys.sort.each {|k|
    v = top[k]
    puts "#{k}: #{v}"
  }

  if result.to_i == 0
    exit 0
  elsif result.exited?
    exit result.exitstatus
  else
    exit 1
  end
end

usage(false) if ARGV.empty?
main_invoke
