#!/usr/bin/env ruby

def usage(status)
  puts <<'End'
Usage:
  procmemsize command [args...]
  procmemsize -p pid
End
  exit status
end

require 'io/nonblock'
require 'tsort'
require 'optparse'

require "fcntl"

STDOUT.sync = true

class IO
  def close_on_exec
    self.fcntl(Fcntl::F_GETFD) & Fcntl::FD_CLOEXEC != 0
  end

  def close_on_exec=(v)
    flags = self.fcntl(Fcntl::F_GETFD)
    if v
      flags |= Fcntl::FD_CLOEXEC
    else
      flags &= ~Fcntl::FD_CLOEXEC
    end
    self.fcntl(Fcntl::F_SETFD, flags)
    v
  end
end

class Hash
  include TSort
  alias tsort_each_node each_key
  def tsort_each_child(node, &block)
    fetch(node) { {} }.each_key(&block)
  end
end

class ProcessScanner
  def initialize(*roots)
    @not_interest = {}
    @roots = roots
  end

  def scan
    entries = get_entries
    status_hash = read_status(entries)
    trace(status_hash)
  end

  def get_entries
    entries = Dir.entries("/proc")

    # reject non-pid entries
    entries.reject! {|n| /\A\d+\z/ !~ n }

    # reject non-existing processes
    entries_hash = {}
    entries.each {|n| entries_hash[n.to_i] = true }
    @not_interest.reject! {|pid, _| !entries_hash[pid] }

    # reject not-interesting processes
    entries.reject! {|n| @not_interest[n.to_i] }

    entries
  end

  def read_status(entries)
    status_hash = {}
    entries.each {|n|
      pid = n.to_i
      status = {}
      begin
        f = File.open("/proc/#{n}/status")
      rescue Errno::ENOENT
        next
      end
      begin
        f.each_line {|line|
          if /^([A-Za-z]+):\s*(.*)/ =~ line.chomp
            key = $1
            val = $2
            status[key] = val
          end
        }
      ensure
        f.close
      end

      status_hash[pid] = status
    }
    status_hash
  end

  def trace(status_hash)
    parent_pid = {}
    children_pids = {}
    status_hash.each {|pid, status|
      if status['PPid']
        ppid = status['PPid'].to_i
        parent_pid[pid] = ppid
        children_pids[ppid] ||= {}
        children_pids[ppid][pid] = true
      end
    }

    pids = children_pids.tsort
    interest = []
    pids.reverse_each {|pid|
      if @roots.include? pid
        interest << status_hash[pid]
      elsif !parent_pid[pid]
        @not_interest[pid] = true
      elsif @not_interest[parent_pid[pid]]
        @not_interest[pid] = true
      else
        interest << status_hash[pid]
      end
    }
    interest
  end

  def self.parse_memsize(str)
    if /\A(\d+) kB\z/ =~ str
      return $1.to_i * 1024
    end
    raise "unexpected memsize format: #{str.inspect}"
  end
end

def update_top(scanner, top)
  begin
    interest = scanner.scan
  rescue TSort::Cyclic
    sleep 0.01
    retry
  end
  interest.each {|status|
    updated_keys = []
    status.each {|k,v|
      next if /\AVm/ !~ k
      if !top[k] || ProcessScanner.parse_memsize(top[k]) < ProcessScanner.parse_memsize(v)
        updated_keys << k
        top[k] = v
      end
    }
    if !updated_keys.empty?
      line = "#{status['Name']} (#{status['Pid']}):"
      updated_keys.sort.each {|k|
        line << " #{k}=#{status[k].gsub(/\s+/, '')}"
      }
      puts line
    end
  }
end

def output_result(top)
  top.keys.sort.each {|k|
    v = top[k]
    puts "#{k}: #{v}"
  }
end

def main_invoke(command, *args)
  pipe_r, pipe_w = IO.pipe
  pipe_r.nonblock = true
  pipe_w.nonblock = true

  trap(:CHLD) { pipe_w.syswrite "a" }

  detect_exec_pipe_r, detect_exec_pipe_w = IO.pipe
  detect_exec_pipe_w.close_on_exec = true

  command_pid = fork {
    detect_exec_pipe_r.close
    exec [command, command], *args
  }

  detect_exec_pipe_w.close
  detect_exec_pipe_r.read
  detect_exec_pipe_r.close

  scanner = ProcessScanner.new(command_pid)
  top = {}

  begin
    while Process.waitpid(command_pid, Process::WNOHANG) == nil
      update_top(scanner, top)
      IO.select([pipe_r], nil, nil, 0.1)
      pipe_r.sysread(4096) rescue nil
    end
    result = $?
  ensure
    output_result(top)
  end

  if result.to_i == 0
    exit 0
  elsif result.exited?
    exit result.exitstatus
  else
    exit 1
  end
end

def main_attach(pid)
  begin
    Process.kill(0, pid)
  rescue Errno::ESRCH
    STDERR.puts "no process #{pid}"
    exit 1
  end

  trap(:TERM) { exit 0 }

  scanner = ProcessScanner.new(pid)
  top = {}

  begin
    while true
      begin
        Process.kill(0, pid)
      rescue Errno::ESRCH
        break
      end
      update_top(scanner, top)
      sleep 0.1
    end
  ensure
    output_result(top)
  end
end

opts = {}

o = OptionParser.new
o.def_option('-p PID') {|pid|
  opts[:pid] = pid.to_i
}
o.order!

if opts[:pid]
  main_attach(opts[:pid])
elsif !ARGV.empty?
  main_invoke(ARGV[0], *ARGV[1..-1])
else
  usage(false)
end

